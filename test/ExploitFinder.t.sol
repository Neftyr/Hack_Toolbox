// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import {StdCheats} from "forge-std/StdCheats.sol";
import {Test, console} from "forge-std/Test.sol";
import {Thief} from "../src/Thief.sol";
import {Vm} from "forge-std/Vm.sol";

contract ExploitFinder is StdCheats, Test {
    address private constant TARGET = 0x1C11521f858dd24263133C4cCE9b7e7081061463;
    address private constant HUNTED = 0xe5760847db2f10A74Fc575B4803df5fe129811C1;
    address private constant HACKER = 0x50e2a33B9E04e78bF1F1d1F94b0be95Be63C23e7;
    //0xffffffffffffffffffffffff9bccea3641fa93215e8e0b184dddd5b225460ca2
    uint256 deployerKey = vm.envUint("PRIVATE_KEY");

    function setUp() external {}

    function testFindExploit(int256 randomNumber) external returns (int256) {
        vm.startPrank(HACKER);

        Thief newThief = new Thief(572038313094850821099624258919152072749626292255);
        vm.expectRevert();
        (bool success, ) = address(newThief).call(abi.encodeWithSignature("stealNFT()"));

        if (success) {
            return randomNumber;
        }

        vm.stopPrank();
    }

    function isUint128(uint256 num) public pure returns (bool) {
        uint128 maxValue = 2 ** 128 - 1;
        return num <= maxValue;
    }

    function isUint256(uint256 number) public pure returns (bool) {
        if (type(uint256).max >= number) {
            return true;
        } else {
            return false;
        }
    }
}
